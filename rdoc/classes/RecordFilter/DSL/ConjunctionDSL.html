<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: RecordFilter::DSL::ConjunctionDSL</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">RecordFilter::DSL::ConjunctionDSL</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/lib/record_filter/dsl/conjunction_dsl_rb.html">
                lib/record_filter/dsl/conjunction_dsl.rb
                </a>
        &nbsp;(<a href="http://github.com/aub/record_filter/tree/master/lib/record_filter/dsl/conjunction_dsl.rb"><acronym title="Concurrent Versioning System">CVS</acronym></a>)
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                Object
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
The <a href="ConjunctionDSL.html">ConjunctionDSL</a> is used for specifying
restrictions, conjunctions and joins, <a
href="ConjunctionDSL.html#M000029">with</a> methods that can be accessed
from any point in a filter declaration. The where method is used for
creating restrictions, conjunctions are specified through <a
href="ConjunctionDSL.html#M000030">any_of</a>, <a
href="ConjunctionDSL.html#M000031">all_of</a>, <a
href="ConjunctionDSL.html#M000032">none_of</a> and <a
href="ConjunctionDSL.html#M000033">not_all_of</a>, and joins are described
by <a href="ConjunctionDSL.html#M000034">having</a> and <a
href="ConjunctionDSL.html#M000035">join</a>.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000031">all_of</a>&nbsp;&nbsp;
      <a href="#M000030">any_of</a>&nbsp;&nbsp;
      <a href="#M000036">filter_class</a>&nbsp;&nbsp;
      <a href="#M000034">having</a>&nbsp;&nbsp;
      <a href="#M000035">join</a>&nbsp;&nbsp;
      <a href="#M000037">method_missing</a>&nbsp;&nbsp;
      <a href="#M000032">none_of</a>&nbsp;&nbsp;
      <a href="#M000033">not_all_of</a>&nbsp;&nbsp;
      <a href="#M000029">with</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000031" class="method-detail">
        <a name="M000031"></a>

        <div class="method-heading">
          <a href="#M000031" class="method-signature">
          <span class="method-name">all_of</span><span class="method-args">(&amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Add a where clause that will pass only if all of the conditions specified
within it are true. Any restrictions created inside the given block are
AND&#8216;ed together in the final query, and the block can contain any
number of joins, restrictions, or other conjunctions.
</p>
<pre>
  Blog.filter do
    all_of do
      with(:created_at, nil)
      with(:created_at).greater_than(3.days.ago)
    end
  end

  # :conditions =&gt; { ['blogs.created_at IS NULL AND blogs.created_at &gt; ?', 3.days.ago] }
</pre>
<h4>Parameters</h4>
<table>
<tr><td valign="top">block&lt;Proc&gt;:</td><td>The block can contain any sequence of calls, and the conditions that it
contains will be AND&#8216;ed together to create a where clause.

</td></tr>
</table>
<h4>Returns</h4>
<p>
nil
</p>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000031-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000031-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 101</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">all_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:all_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-keyword kw">nil</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000030" class="method-detail">
        <a name="M000030"></a>

        <div class="method-heading">
          <a href="#M000030" class="method-signature">
          <span class="method-name">any_of</span><span class="method-args">(&amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Add a where clause that will pass if any of the conditions specified within
it are true. Any restrictions created inside the given block are
OR&#8216;ed together in the final query, and the block can contain any
number of joins, restrictions, or other conjunctions.
</p>
<pre>
  Blog.filter do
    any_of do
      with(:created_at, nil)
      with(:created_at).greater_than(3.days.ago)
    end
  end

  # :conditions =&gt; { ['blogs.created_at IS NULL OR blogs.created_at &gt; ?', 3.days.ago] }
</pre>
<h4>Parameters</h4>
<table>
<tr><td valign="top">block&lt;Proc&gt;:</td><td>The block can contain any sequence of calls, and the conditions that it
contains will be OR&#8216;ed together to create a where clause.

</td></tr>
</table>
<h4>Returns</h4>
<p>
nil
</p>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000030-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000030-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 74</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">any_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:any_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-keyword kw">nil</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000036" class="method-detail">
        <a name="M000036"></a>

        <div class="method-heading">
          <a href="#M000036" class="method-signature">
          <span class="method-name">filter_class</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Access the class that the current filter is being applied to. This is
necessary because the filter is evaluated in the context of the <a
href="../DSL.html">DSL</a> object, so self will not give access to any
methods that need to be called on the filtered class. It is especially
useful in named filters that may be defined in a way that allows them to
apply to multiple classes.
</p>
<h4>Returns</h4>
<table>
<tr><td valign="top">Class:</td><td>The class that is currently being filtered.

</td></tr>
</table>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000036-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000036-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 242</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">filter_class</span>
        <span class="ruby-ivar">@model_class</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000034" class="method-detail">
        <a name="M000034"></a>

        <div class="method-heading">
          <a href="#M000034" class="method-signature">
          <span class="method-name">having</span><span class="method-args">(join_type, association=nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Create an implicit <a href="ConjunctionDSL.html#M000035">join</a> using an
association as the target. This method allows you to easily specify a <a
href="ConjunctionDSL.html#M000035">join</a> without specifying the columns
to use by taking any needed data from the given ActiveRecord association.
If provided, the block will be evaluated in the context of the table that
has been joined, so any restrictions or other joins will be performed using
its columns and associations. For example, if a Post has_many comments then
the following code will <a href="ConjunctionDSL.html#M000035">join</a> to
the comments table and restrict the comments based on their created_at
field:
</p>
<pre>
  Post.filter do
    having(:comments) do
      with(:created_at).greater_than(3.days.ago)
    end
  end
</pre>
<p>
If one argument is given, it is assumed to represent the name of the
association that will be used for the <a
href="ConjunctionDSL.html#M000035">join</a> and a <a
href="ConjunctionDSL.html#M000035">join</a> type of :inner will be used by
default. If two arguments are provided, the first one is assumed to be the
<a href="ConjunctionDSL.html#M000035">join</a> type, which can be one of
:inner, :left or :right and the second one is the association name. An
alias will automatically be created for the joined table named
&quot;#{left_table}__#{association_name}&quot;, so in the above example,
the alias would be posts__comments. It is also possible to provide a hash
as the association name, in which case a trail of associations can be
joined in one statment.
</p>
<h4>Parameters</h4>
<table>
<tr><td valign="top">join_type&lt;Symbol&gt;:</td><td>Specifies the type of <a href="ConjunctionDSL.html#M000035">join</a> to
perform, and can be one of :inner, :left or :right. :left and :right will
create left and right outer joins, respectively.

</td></tr>
<tr><td valign="top">association&lt;Symbol&gt;:</td><td>The name of the association to use as a base for the <a
href="ConjunctionDSL.html#M000035">join</a>.

</td></tr>
</table>
<h4>Returns</h4>
<table>
<tr><td valign="top"><a href="ConjunctionDSL.html">ConjunctionDSL</a>:</td><td>A <a href="../DSL.html">DSL</a> object is returned in order to allow
constructs like: <a
href="ConjunctionDSL.html#M000034">having</a>(:comments).<a
href="ConjunctionDSL.html#M000029">with</a>(:offensive, true)

</td></tr>
</table>
<h4>Alternatives</h4>
<p>
If only one argument is given, the <a
href="ConjunctionDSL.html#M000035">join</a> type will default to :inner and
the first argument will be used as the association name.
</p>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000034-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000034-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 196</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">having</span>(<span class="ruby-identifier">join_type</span>, <span class="ruby-identifier">association</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">nil?</span>
          <span class="ruby-identifier">association</span>, <span class="ruby-identifier">join_type</span> = <span class="ruby-identifier">join_type</span>, <span class="ruby-keyword kw">nil</span>
        <span class="ruby-keyword kw">end</span>
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_join</span>(<span class="ruby-identifier">association</span>, <span class="ruby-identifier">join_type</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000035" class="method-detail">
        <a name="M000035"></a>

        <div class="method-heading">
          <a href="#M000035" class="method-signature">
          <span class="method-name">join</span><span class="method-args">(clazz, join_type, table_alias=nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Create an explicit <a href="ConjunctionDSL.html#M000035">join</a> on the
table of the given class. This method allows more complex joins to be
speficied than can be created using <a
href="ConjunctionDSL.html#M000034">having</a>, including jump joins and
ones that include conditions on column values. The method accepts a block
that can contain any sequence of conjunctions, restrictions, or other
joins, but it must also contain at least one call to <a
href="JoinDSL.html#M000004">JoinDSL.on</a> to specify the conditions for
the <a href="ConjunctionDSL.html#M000035">join</a>.
</p>
<h4>Parameters</h4>
<table>
<tr><td valign="top">clazz&lt;Class&gt;:</td><td>The class that is being joined to.

</td></tr>
<tr><td valign="top">join_type&lt;Symbol&gt;:</td><td>Indicates the type of <a href="ConjunctionDSL.html#M000035">join</a> to use
and must be one of :inner, :left or :right, where :left or :right will
create a LEFT or RIGHT OUTER <a href="ConjunctionDSL.html#M000035">join</a>
respectively.

</td></tr>
<tr><td valign="top">table_alias&lt;String, optional&gt;:</td><td>If provided, will specify an alias to use in the SQL when referring to the
joined table. If the argument is not given, the alias will be
&quot;#{left_table}__#{clazz.name}&quot;

</td></tr>
</table>
<p>
block&lt;Proc&gt;
</p>
<pre>
  The contents of the join block can contain any sequence of conjunctions, restrictions, or joins.
</pre>
<h4>Returns</h4>
<table>
<tr><td valign="top"><a href="JoinDSL.html">JoinDSL</a>:</td><td>A <a href="../DSL.html">DSL</a> object that can be used to specify the
contents of the <a href="ConjunctionDSL.html#M000035">join</a>. Returning
this value allows for constructions like: <a
href="ConjunctionDSL.html#M000035">join</a>(Comment, :inner).on(:id =&gt;
:post_id)

</td></tr>
</table>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000035-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000035-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 227</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">join</span>(<span class="ruby-identifier">clazz</span>, <span class="ruby-identifier">join_type</span>, <span class="ruby-identifier">table_alias</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_class_join</span>(<span class="ruby-identifier">clazz</span>, <span class="ruby-identifier">join_type</span>, <span class="ruby-identifier">table_alias</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000037" class="method-detail">
        <a name="M000037"></a>

        <div class="method-heading">
          <a href="#M000037" class="method-signature">
          <span class="method-name">method_missing</span><span class="method-args">(method, *args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Enable calling of named filters from within other filters by catching
unknown calls and assuming that they are to named filters. This enables the
following examples:
</p>
<pre>
  class Post &lt; ActiveRecord::Base
    has_many :comments
    named_filter(:empty) { with(:contents).nil }
  end

  class Comment &lt; ActiveRecord::Base
    belongs_to :post
    named_filter(:offensive) { |value| with(:offensive, value) }
  end

  Post.filter do
    with(:created_at).less_than(1.hour.ago)
    empty
  end

  # Results in:
  # :conditions =&gt; { ['posts.created_at &lt; ? AND posts.contents IS NULL', 1.hour.ago] }
  # And even cooler:

  Post.filter do
    having(:comments).offensive(true)
  end

  # Results in:
  # :conditions =&gt; { ['posts__comments.offensive = ?', true] }
  # :joins =&gt; { 'INNER JOIN &quot;comments&quot; AS posts__comments ON &quot;posts&quot;.id = posts__comments.post_id' }
</pre>
<h4>Parameters</h4>
<table>
<tr><td valign="top">args&lt;Array&gt;:</td><td>The arguments to pass to the named filter when called.

</td></tr>
</table>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000037-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000037-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 280</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_named_filter</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000032" class="method-detail">
        <a name="M000032"></a>

        <div class="method-heading">
          <a href="#M000032" class="method-signature">
          <span class="method-name">none_of</span><span class="method-args">(&amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Add a where clause that will pass only if none of the conditions specified
within it are true. Any restrictions created inside the given block are
OR&#8216;ed together in the final query and the result is negated. The
block can contain any number of joins, restrictions, or other conjunctions.
</p>
<pre>
  Blog.filter do
    none_of do
      with(:created_at, nil)
      with(:created_at).greater_than(3.days.ago)
    end
  end

  # :conditions =&gt; { ['NOT (blogs.created_at IS NULL OR blogs.created_at &gt; ?)', 3.days.ago] }
</pre>
<h4>Parameters</h4>
<table>
<tr><td valign="top">block&lt;Proc&gt;:</td><td>The block can contain any sequence of calls, and the conditions that it
contains will be OR&#8216;ed together and then negated to create a where
clause.

</td></tr>
</table>
<h4>Returns</h4>
<p>
nil
</p>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000032-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000032-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 128</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">none_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:none_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-keyword kw">nil</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000033" class="method-detail">
        <a name="M000033"></a>

        <div class="method-heading">
          <a href="#M000033" class="method-signature">
          <span class="method-name">not_all_of</span><span class="method-args">(&amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Add a where clause that will pass unless all of the conditions specified
within it are true. Any restrictions created inside the given block are
AND&#8216;ed together in the final query and the result is negated. The
block can contain any number of joins, restrictions, or other conjunctions.
</p>
<pre>
  Blog.filter do
    none_of do
      with(:created_at, nil)
      with(:created_at).greater_than(3.days.ago)
    end
  end

  # :conditions =&gt; { ['NOT (blogs.created_at IS NULL AND blogs.created_at &gt; ?)', 3.days.ago] }
</pre>
<h4>Parameters</h4>
<table>
<tr><td valign="top">block&lt;Proc&gt;:</td><td>The block can contain any sequence of calls, and the conditions that it
contains will be AND&#8216;ed together and then negated to create a where
clause.

</td></tr>
</table>
<h4>Returns</h4>
<p>
nil
</p>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000033-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000033-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 155</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">not_all_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:not_all_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
        <span class="ruby-keyword kw">nil</span>
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000029" class="method-detail">
        <a name="M000029"></a>

        <div class="method-heading">
          <a href="#M000029" class="method-signature">
          <span class="method-name">with</span><span class="method-args">(column, value=Restriction::DEFAULT_VALUE)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Specify a condition on the given column, which will be added to the WHERE
clause of the resulting query. This method returns a <a
href="Restriction.html">Restriction</a> object, which can be called <a
href="ConjunctionDSL.html#M000029">with</a> any of the specific restriction
methods described there in order to create many types of conditions. If
both a column name and a value are passed, this will automatically create
an equality condition, so the following two examples are equal:
</p>
<pre>
  with(:permalink, 'junk')
  with(:permalink).equal_to('junk')
</pre>
<p>
If nil is passed as the second argument, an is_null restriction will
automatically be created, so these two examples are equal as well:
</p>
<pre>
  with(:permalink, nil)
  with(:permalink).is_null
</pre>
<p>
This method can be called at any point in the filter specification, and the
appropriate clauses will be created if it is called within or other
conjunctions.
</p>
<h4>Parameters</h4>
<table>
<tr><td valign="top">column&lt;Symbol&gt;:</td><td>The name of the column to restrict. The column is assumed to exist in the
table that is currently in scope. In the outer block of a filter, that
would be the table being filtered, and within joins it would be the table
being joined.

</td></tr>
<tr><td valign="top">value&lt;value, optional&gt;:</td><td>If specified, the value will be used to automatically create either an
equality restriction or an IS NULL test, as described above.

</td></tr>
</table>
<h4>Returns</h4>
<table>
<tr><td valign="top"><a href="Restriction.html">Restriction</a>:</td><td>A restriction object that can be used to create a specific condition. See
the API in <a href="Restriction.html">Restriction</a> for options.

</td></tr>
</table>
<h4>Alternatives</h4>
<p>
The value parameter is optional, as described above.
</p>
<p>
@public
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000029-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000029-source">
<pre>
<span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 48</span>
      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">with</span>(<span class="ruby-identifier">column</span>, <span class="ruby-identifier">value</span>=<span class="ruby-constant">Restriction</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_VALUE</span>)
        <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_restriction</span>(<span class="ruby-identifier">column</span>, <span class="ruby-identifier">value</span>)
      <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>