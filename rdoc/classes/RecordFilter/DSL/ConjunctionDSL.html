<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>: RecordFilter::DSL::ConjunctionDSL [record_filter 0.9.3]</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../rdoc-style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>Class</span>
          RecordFilter::DSL::ConjunctionDSL
        </h1>
        <ol class='paths'>
          <li>
            <a href="../../../files/lib/record_filter/dsl/conjunction_dsl_rb.html">lib/record_filter/dsl/conjunction_dsl.rb</a>
            (<a href="http://github.com/aub/record_filter/tree/master/lib/record_filter/dsl/conjunction_dsl.rb">view online</a>)
          </li>
        </ol>
        <div class='parent'>
          Parent:
          <strong>Object</strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            <p>
            The <a href="ConjunctionDSL.html">ConjunctionDSL</a> is used for specifying
            restrictions, conjunctions and joins, with methods that can be accessed
            from any point in a filter declaration. The where method is used for
            creating restrictions, conjunctions are specified through <a
            href="ConjunctionDSL.html#M000027">any_of</a>, <a
            href="ConjunctionDSL.html#M000028">all_of</a>, <a
            href="ConjunctionDSL.html#M000029">none_of</a> and <a
            href="ConjunctionDSL.html#M000030">not_all_of</a>, and joins are described
            by having and join.
            </p>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>public instance</h3>
            <ol>
              <li><a href="#M000028">all_of</a></li>
              <li><a href="#M000027">any_of</a></li>
              <li><a href="#M000033">filter_class</a></li>
              <li><a href="#M000031">having</a></li>
              <li><a href="#M000032">join</a></li>
              <li><a href="#M000034">method_missing</a></li>
              <li><a href="#M000029">none_of</a></li>
              <li><a href="#M000030">not_all_of</a></li>
              <li><a href="#M000026">with</a></li>
            </ol>
          </div>
          <div id='section'>
            <div id='methods'>
              <h2>Public instance methods</h2>
              <div class='public-instance method' id='method-M000028'>
                <a name='M000028'>      </a>
                <div class='synopsis'>
                  <span class='name'>all_of</span>
                  <span class='arguments'>(&amp;block)</span>
                </div>
                <div class='description'>
                  <p>
                  Add a where clause that will pass only if all of the conditions specified
                  within it are true. Any restrictions created inside the given block are
                  AND&#8217;ed together in the final query, and the block can contain any
                  number of joins, restrictions, or other conjunctions.
                  </p>
                  <pre>Blog.filter do&#x000A;  all_of do&#x000A;    with(:created_at, nil)&#x000A;    with(:created_at).greater_than(3.days.ago)&#x000A;  end&#x000A;end&#x000A;&#x000A;# :conditions =&gt; { ['blogs.created_at IS NULL AND blogs.created_at &gt; ?', 3.days.ago] }</pre>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">block<Proc>:</td><td>The block can contain any sequence of calls, and the conditions that it
                  contains will be AND&#8217;ed together to create a where clause.
                  
                  </td></tr>
                  </table>
                  <h4>Returns</h4>
                  <p>
                  nil
                  </p>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000028-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000028-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 101</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">all_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:all_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword kw">nil</span>&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000027'>
                <a name='M000027'>      </a>
                <div class='synopsis'>
                  <span class='name'>any_of</span>
                  <span class='arguments'>(&amp;block)</span>
                </div>
                <div class='description'>
                  <p>
                  Add a where clause that will pass if any of the conditions specified within
                  it are true. Any restrictions created inside the given block are
                  OR&#8217;ed together in the final query, and the block can contain any
                  number of joins, restrictions, or other conjunctions.
                  </p>
                  <pre>Blog.filter do&#x000A;  any_of do&#x000A;    with(:created_at, nil)&#x000A;    with(:created_at).greater_than(3.days.ago)&#x000A;  end&#x000A;end&#x000A;&#x000A;# :conditions =&gt; { ['blogs.created_at IS NULL OR blogs.created_at &gt; ?', 3.days.ago] }</pre>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">block<Proc>:</td><td>The block can contain any sequence of calls, and the conditions that it
                  contains will be OR&#8217;ed together to create a where clause.
                  
                  </td></tr>
                  </table>
                  <h4>Returns</h4>
                  <p>
                  nil
                  </p>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000027-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000027-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 74</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">any_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:any_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword kw">nil</span>&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000033'>
                <a name='M000033'>      </a>
                <div class='synopsis'>
                  <span class='name'>filter_class</span>
                  <span class='arguments'>()</span>
                </div>
                <div class='description'>
                  <p>
                  Access the class that the current filter is being applied to. This is
                  necessary because the filter is evaluated in the context of the <a
                  href="DSL.html">DSL</a> object, so self will not give access to any methods
                  that need to be called on the filtered class. It is especially useful in
                  named filters that may be defined in a way that allows them to apply to
                  multiple classes.
                  </p>
                  <h4>Returns</h4>
                  <table>
                  <tr><td valign="top">Class:</td><td>The class that is currently being filtered.
                  
                  </td></tr>
                  </table>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000033-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000033-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 242</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">filter_class</span>&#x000A;        <span class="ruby-ivar">@model_class</span>&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000031'>
                <a name='M000031'>      </a>
                <div class='synopsis'>
                  <span class='name'>having</span>
                  <span class='arguments'>(join_type, association=nil, &amp;block)</span>
                </div>
                <div class='description'>
                  <p>
                  Create an implicit join using an association as the target. This method
                  allows you to easily specify a join without specifying the columns to use
                  by taking any needed data from the given ActiveRecord association. If
                  provided, the block will be evaluated in the context of the table that has
                  been joined, so any restrictions or other joins will be performed using its
                  columns and associations. For example, if a Post has_many comments then the
                  following code will join to the comments table and restrict the comments
                  based on their created_at field:
                  </p>
                  <pre>Post.filter do&#x000A;  having(:comments) do&#x000A;    with(:created_at).greater_than(3.days.ago)&#x000A;  end&#x000A;end</pre>
                  <p>
                  If one argument is given, it is assumed to represent the name of the
                  association that will be used for the join and a join type of :inner will
                  be used by default. If two arguments are provided, the first one is assumed
                  to be the join type, which can be one of :inner, :left or :right and the
                  second one is the association name. An alias will automatically be created
                  for the joined table named
                  &#8220;#{left_table}__#{association_name}&#8221;, so in the above example,
                  the alias would be posts__comments. It is also possible to provide a hash
                  as the association name, in which case a trail of associations can be
                  joined in one statment.
                  </p>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">join_type<Symbol>:</td><td>Specifies the type of join to perform, and can be one of :inner, :left or
                  :right. :left and :right will create left and right outer joins,
                  respectively.
                  
                  </td></tr>
                  <tr><td valign="top">association<Symbol>:</td><td>The name of the association to use as a base for the join.
                  
                  </td></tr>
                  </table>
                  <h4>Returns</h4>
                  <table>
                  <tr><td valign="top">ConjunctionDSL:</td><td>A <a href="DSL.html">DSL</a> object is returned in order to allow
                  constructs like: having(:comments).with(:offensive, true)
                  
                  </td></tr>
                  </table>
                  <h4>Alternatives</h4>
                  <p>
                  If only one argument is given, the join type will default to :inner and the
                  first argument will be used as the association name.
                  </p>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000031-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000031-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 196</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">having</span>(<span class="ruby-identifier">join_type</span>, <span class="ruby-identifier">association</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">association</span>.<span class="ruby-identifier">nil?</span>&#x000A;          <span class="ruby-identifier">association</span>, <span class="ruby-identifier">join_type</span> = <span class="ruby-identifier">join_type</span>, <span class="ruby-keyword kw">nil</span>&#x000A;        <span class="ruby-keyword kw">end</span>&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_join</span>(<span class="ruby-identifier">association</span>, <span class="ruby-identifier">join_type</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000032'>
                <a name='M000032'>      </a>
                <div class='synopsis'>
                  <span class='name'>join</span>
                  <span class='arguments'>(clazz, join_type, table_alias=nil, &amp;block)</span>
                </div>
                <div class='description'>
                  <p>
                  Create an explicit join on the table of the given class. This method allows
                  more complex joins to be speficied than can be created using having,
                  including jump joins and ones that include conditions on column values. The
                  method accepts a block that can contain any sequence of conjunctions,
                  restrictions, or other joins, but it must also contain at least one call to
                  <a href="JoinDSL.html#M000004">JoinDSL.on</a> to specify the conditions for
                  the join.
                  </p>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">clazz<Class>:</td><td>The class that is being joined to.
                  
                  </td></tr>
                  <tr><td valign="top">join_type<Symbol>:</td><td>Indicates the type of join to use and must be one of :inner, :left or
                  :right, where :left or :right will create a LEFT or RIGHT OUTER join
                  respectively.
                  
                  </td></tr>
                  <tr><td valign="top">table_alias<String, optional>:</td><td>If provided, will specify an alias to use in the SQL when referring to the
                  joined table. If the argument is not given, the alias will be
                  &#8220;#{left_table}__#{clazz.name}&#8220;
                  
                  </td></tr>
                  </table>
                  <p>
                  block<Proc>
                  </p>
                  <pre>The contents of the join block can contain any sequence of conjunctions, restrictions, or joins.</pre>
                  <h4>Returns</h4>
                  <table>
                  <tr><td valign="top">JoinDSL:</td><td>A <a href="DSL.html">DSL</a> object that can be used to specify the
                  contents of the join. Returning this value allows for constructions like:
                  join(Comment, :inner).on(:id => :post_id)
                  
                  </td></tr>
                  </table>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000032-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000032-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 227</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">join</span>(<span class="ruby-identifier">clazz</span>, <span class="ruby-identifier">join_type</span>, <span class="ruby-identifier">table_alias</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_class_join</span>(<span class="ruby-identifier">clazz</span>, <span class="ruby-identifier">join_type</span>, <span class="ruby-identifier">table_alias</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000034'>
                <a name='M000034'>      </a>
                <div class='synopsis'>
                  <span class='name'>method_missing</span>
                  <span class='arguments'>(method, *args)</span>
                </div>
                <div class='description'>
                  <p>
                  Enable calling of named filters from within other filters by catching
                  unknown calls and assuming that they are to named filters. This enables the
                  following examples:
                  </p>
                  <pre>class Post &lt; ActiveRecord::Base&#x000A;  has_many :comments&#x000A;  named_filter(:empty) { with(:contents).nil }&#x000A;end&#x000A;&#x000A;class Comment &lt; ActiveRecord::Base&#x000A;  belongs_to :post&#x000A;  named_filter(:offensive) { |value| with(:offensive, value) }&#x000A;end&#x000A;&#x000A;Post.filter do&#x000A;  with(:created_at).less_than(1.hour.ago)&#x000A;  empty&#x000A;end&#x000A;&#x000A;# Results in:&#x000A;# :conditions =&gt; { ['posts.created_at &lt; ? AND posts.contents IS NULL', 1.hour.ago] }&#x000A;# And even cooler:&#x000A;&#x000A;Post.filter do&#x000A;  having(:comments).offensive(true)&#x000A;end&#x000A;&#x000A;# Results in:&#x000A;# :conditions =&gt; { ['posts__comments.offensive = ?', true] }&#x000A;# :joins =&gt; { 'INNER JOIN &quot;comments&quot; AS posts__comments ON &quot;posts&quot;.id = posts__comments.post_id' }</pre>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">args<Array>:</td><td>The arguments to pass to the named filter when called.
                  
                  </td></tr>
                  </table>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000034-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000034-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 280</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_named_filter</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000029'>
                <a name='M000029'>      </a>
                <div class='synopsis'>
                  <span class='name'>none_of</span>
                  <span class='arguments'>(&amp;block)</span>
                </div>
                <div class='description'>
                  <p>
                  Add a where clause that will pass only if none of the conditions specified
                  within it are true. Any restrictions created inside the given block are
                  OR&#8217;ed together in the final query and the result is negated. The
                  block can contain any number of joins, restrictions, or other conjunctions.
                  </p>
                  <pre>Blog.filter do&#x000A;  none_of do&#x000A;    with(:created_at, nil)&#x000A;    with(:created_at).greater_than(3.days.ago)&#x000A;  end&#x000A;end&#x000A;&#x000A;# :conditions =&gt; { ['NOT (blogs.created_at IS NULL OR blogs.created_at &gt; ?)', 3.days.ago] }</pre>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">block<Proc>:</td><td>The block can contain any sequence of calls, and the conditions that it
                  contains will be OR&#8217;ed together and then negated to create a where
                  clause.
                  
                  </td></tr>
                  </table>
                  <h4>Returns</h4>
                  <p>
                  nil
                  </p>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000029-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000029-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 128</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">none_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:none_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword kw">nil</span>&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000030'>
                <a name='M000030'>      </a>
                <div class='synopsis'>
                  <span class='name'>not_all_of</span>
                  <span class='arguments'>(&amp;block)</span>
                </div>
                <div class='description'>
                  <p>
                  Add a where clause that will pass unless all of the conditions specified
                  within it are true. Any restrictions created inside the given block are
                  AND&#8217;ed together in the final query and the result is negated. The
                  block can contain any number of joins, restrictions, or other conjunctions.
                  </p>
                  <pre>Blog.filter do&#x000A;  none_of do&#x000A;    with(:created_at, nil)&#x000A;    with(:created_at).greater_than(3.days.ago)&#x000A;  end&#x000A;end&#x000A;&#x000A;# :conditions =&gt; { ['NOT (blogs.created_at IS NULL AND blogs.created_at &gt; ?)', 3.days.ago] }</pre>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">block<Proc>:</td><td>The block can contain any sequence of calls, and the conditions that it
                  contains will be AND&#8217;ed together and then negated to create a where
                  clause.
                  
                  </td></tr>
                  </table>
                  <h4>Returns</h4>
                  <p>
                  nil
                  </p>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000030-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000030-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 155</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">not_all_of</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_conjunction</span>(<span class="ruby-identifier">:not_all_of</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;        <span class="ruby-keyword kw">nil</span>&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='public-instance method' id='method-M000026'>
                <a name='M000026'>      </a>
                <div class='synopsis'>
                  <span class='name'>with</span>
                  <span class='arguments'>(column, value=Restriction::DEFAULT_VALUE)</span>
                </div>
                <div class='description'>
                  <p>
                  Specify a condition on the given column, which will be added to the WHERE
                  clause of the resulting query. This method returns a <a
                  href="Restriction.html">Restriction</a> object, which can be called with
                  any of the specific restriction methods described there in order to create
                  many types of conditions. If both a column name and a value are passed,
                  this will automatically create an equality condition, so the following two
                  examples are equal:
                  </p>
                  <pre>with(:permalink, 'junk')&#x000A;with(:permalink).equal_to('junk')</pre>
                  <p>
                  If nil is passed as the second argument, an is_null restriction will
                  automatically be created, so these two examples are equal as well:
                  </p>
                  <pre>with(:permalink, nil)&#x000A;with(:permalink).is_null</pre>
                  <p>
                  This method can be called at any point in the filter specification, and the
                  appropriate clauses will be created if it is called within or other
                  conjunctions.
                  </p>
                  <h4>Parameters</h4>
                  <table>
                  <tr><td valign="top">column<Symbol>:</td><td>The name of the column to restrict. The column is assumed to exist in the
                  table that is currently in scope. In the outer block of a filter, that
                  would be the table being filtered, and within joins it would be the table
                  being joined.
                  
                  </td></tr>
                  <tr><td valign="top">value<value, optional>:</td><td>If specified, the value will be used to automatically create either an
                  equality restriction or an IS NULL test, as described above.
                  
                  </td></tr>
                  </table>
                  <h4>Returns</h4>
                  <table>
                  <tr><td valign="top">Restriction:</td><td>A restriction object that can be used to create a specific condition. See
                  the API in <a href="Restriction.html">Restriction</a> for options.
                  
                  </td></tr>
                  </table>
                  <h4>Alternatives</h4>
                  <p>
                  The value parameter is optional, as described above.
                  </p>
                  <p>
                  @public
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000026-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000026-source'><span class="ruby-comment cmt"># File lib/record_filter/dsl/conjunction_dsl.rb, line 48</span>&#x000A;      <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">with</span>(<span class="ruby-identifier">column</span>, <span class="ruby-identifier">value</span>=<span class="ruby-constant">Restriction</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_VALUE</span>)&#x000A;        <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@conjunction</span>.<span class="ruby-identifier">add_restriction</span>(<span class="ruby-identifier">column</span>, <span class="ruby-identifier">value</span>)&#x000A;      <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
