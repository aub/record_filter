= record_filter

record_filter is a DSL for specifying criteria for ActiveRecord queries in pure Ruby.
It has support for filters created on the fly and for named filters that are associated with object types.
record_filter has the following top-level features:

* Pure ruby API eliminates the need for hard-coded SQL in most cases.
* Works seamlessly with existing ActiveRecord APIs, including named scopes.
* Supports creation of ad-hoc filters as well as named filters that can be associated with object types.
* Allows chaining of filters with each other and with named scopes to create complex queries.
* Takes advantage of the associations in your ActiveRecord objects for a clean implicit join API.

== Installation

  gem install outoftime-record_filter --source=http://gems.github.com

== Usage

=== Ad-hoc filters

  Post.filter do
    with(:permalink, 'blog-post')
    having(:blog).with(:name, 'Blog')
  end

This could be expressed in ActiveRecord as:

  Post.find(:all, :joins => :blog, :conditions => ['posts.permalink = ? AND blogs.name = ?', 'blog-post', 'Blog')

and it returns the same result, a list of Post objects that are returned from the query.

=== Named filters

  class Post < ActiveRecord::Base
    named_filter(:with_title) do |title|
      with(:title, title)
    end
  end

  Post.with_title('posted')

This is the same as the following code using named scopes, and returns the same result:

  class Post < ActiveRecord::Base
    named_scope :with_title, lambda { |title| { :conditions => ['title = ?', title] }}
  end
  
  Post.with_title('scoped')

=== Restrictions

Restrictions are specified through the API using the 'with' function. The first argument to 'with' should be the
name of the field that the restriction applies to. All restriction types can be negated by chaining the 'with'
method with a call to 'not', as seen in some examples below.

==== Equality

If a second argument is supplied, it is assumed that you are 
expressing an equality condition and that argument is used as the value.

  with(:title, 'abc') # :conditions => ['title = ?', 'abc']

Which can be negated with:

  with(:title, 'abc').not # :conditions => ['title <> ?', 'abc']

For the more verbose among us, this can also be specified as:

  with(:title).equal_to('abc') # :conditions => ['title = ?', 'abc']

Other types of restrictions are specified by omitting the second argument to 'with' and chaining it with one of the
restriction methods.

==== Comparison operators

  with(:price).greater_than(10) # :conditions => ['price > ?', 10]

  with(:created_at).less_than(2.days.ago) # :conditions => ['created_at < ?', 2.days.ago]

These methods can also have _or_equal_to tagged onto the end, to obvious affect, and all of the comparison operators are aliased to
their standard single-character variants:

  gt, gte, lt and lte

==== IS NULL

  with(:price, nil) # :conditions => ['price IS NULL']

This short form can also be made explicit by using the is_null, null, or nil functions on with:

  with(:price).is_null # :conditions => ['price IS NULL']

It can be negated either by chaining with the 'not' function or by using is_not_null:

  with(:price).is_not_null # :conditions => ['price IS NOT NULL']
  with(:price).is_null.not # "

==== IN

  with(:id).in([1, 2, 3]) # :conditions => ['id IN (?)', [1, 2, 3]]

==== BETWEEN

  with(:id).between(1, 5) # :conditions => ['id BETWEEN ? AND ?', 1, 5]

The argument to between can also be either a tuple or a range

  with(:created_at).between([Time.now, 3.days.ago]) # :conditions => ['created_at BETWEEN ? AND ?', Time.now, 3.days.ago]

  with(:price).between(1..5) # :conditions => ['price BETWEEN ? AND ?', 1, 5]

==== LIKE

  with(:title).like('%help%') # :conditions => ['title LIKE ?', '%help%']


=== Implicit Joins

Implicit joins are specified using the 'having' function, which takes as its argument the name of an association to join on.

  having(:comments) # :joins => :comments

This function can be chained with calls to 'with' in order to specify conditions on the joined table:

  having(:comments).with(:created_at).gt(2.days.ago) # :joins => :comments, :conditions => ['comments.created_at > ?', 2.days.ago]

It can also take a block that can have any number of conditions or other clauses (including other joins) in it:

  having(:comments) do
    with(:created_at).gt(2.days.ago)
    having(:author).with(:name, 'Bubba')
  end

The 'having' function can also take :inner, :left or :right as its second argument in order to specify that a particular join type
should be used.

=== Explicit joins

In cases where there is no ActiveRecord association that can be used to specify an implicit join, explicit joins are also
supported, using the 'join' function. Its arguments are the class to be joined against, the join type (:inner, left or :right) and
an optional alias for the join table. A block should also be supplied in order to specify the columns to use for the join using the
'on' method.

  Post.filter do
    join(Comment, :inner, :posts__comments_alias) do
      on(:id => :commentable_id)
      on(:commentable_type, 'Post')
    end
  end

=== Conjunctions

The following conjunction types are supported:

* any_of
* all_of
* none_of
* not_all_of

Each takes a block that can contain conditions or joins and will apply the expected boolean logic to the combination.

  any_of
    with(:price, 2)
    with(:price).gt(100)
  end

  # :conditions => ['price = ? OR price > ?', 2, 100]

=== Limits and ordering

  limit(20)

  order(:id, :desc)

Multiple order clauses can be specified, and they will be applied in the order in which they are specified.
When joins are used, order can also take a hash as the first argument that leads to the column to order on through the joins:

  having(:comments).with(:offensive, true)
  order(:comments => :id, :desc)


== LICENSE:

(The MIT License)

Copyright (c) 2008 Mat Brown

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
